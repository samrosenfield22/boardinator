BOARDINATOR MANUAL

I.						Architecture
II. 					ISA
III.					Assembler
	i. 						Features
	ii. 					Tips

---------------------------------------------------------------------------------------
I. Architecture

word size: 			8
instruction size:	16
program addr:		10
sfr addr:			8

There are 8 general-purpose registers (r0-r7).

Calling convention: lmao not yet

---------------------------------------------------------------------------------------
II. ISA
opcode	mnemonic	op0	op1			machine code		example				description
00000	set			dst	literal		00000ddd llllllll	set r0,0x40			dst = literal (literal can be dec or hex)
00001	mov			dst src 		00001ddd 00000sss	mov r1,r0			dst = src
00010	add			dst src 		00010ddd 00000sss	add r1,r0			dst += src
00011	addl		dst lit 		00011ddd llllllll	addl r0,0x40		dst += literal
00100	sub			dst src 		00011ddd 00000sss	sub r1,r0			dst -= src
00101 	subl		dst lit 		00101ddd llllllll	subl r0,1			dst -= lit
00110	xor			dst src 		00100ddd 00000sss	xor r1,r0			dst ^= src
00111	and			dst src 		00101ddd 00000sss	and r1,r0			dst &= src
01000	or			dst src 		00110ddd 00000sss	or r1,r0			dst |= src
01001	cmp			dst src 		00111ddd 00000sss	cmp r1,r0			sets flags (Equal Flag and Greater Less Flag)
01010	not			dst 			01010ddd 00000000	not r0				dst != dst
01011	jmp 		label			010110aa aaaaaaaa	jmp label			goto label
01100	jeq 		label			011000aa aaaaaaaa	jeq label			if(EF) goto label
01101	jne 		label			011010aa aaaaaaaa	jne label			if(!EF) goto label
01110	jgt 		label			011100aa aaaaaaaa	jgt label			if(GLF & !EF) goto label
01111	jlt 		label			011110aa aaaaaaaa	jlt label			if(!GLF & !EF) goto label
10000	jovf		label 			000000aa aaaaaaaa	jovf label 			if(OF) goto label
10001	setstk		adr src 		10000aaa 00000sss 	setstk r1,r0 		stack[adr] = src
10010	getstk		dst adr 		10001ddd 00000aaa	getstk r1,r0 		dst = stack[adr]
10011	getpcl		dst 			10011ddd 00000000	getpcl r5			dst = pc[7:0]
10100	getpch 		dst 			10100ddd 00000000	getpch r4			dst = pc[9:8]
10101	setpc		rhi rlo			10101hhh 00000lll	setpc r4,r5			pc = (hi<<8) | lo

10001	setmem		adr src rn 		10000aaa rn000sss 	setstk r1,r0 		stack[region & adr] = src
10010	getmem		dst adr rn		10001ddd rn000aaa	getstk r1,r0 		dst = stack[region & adr]

xxxxx	setsfr 		reg sfr			10010rrr ssssssss	setsfr r0,MEMCTL	sfr = reg (UNIMPLEMENTED)
xxxxx	getsfr 		reg sfr 		10011rrr ssssssss	getsfr r0,MEMCTL	reg = sfr (UNIMPLEMENTED)

Flags:
EF (equal flag): set when cmp operands are equal
GLF (greater/less than flag): set when op0>op1, cleared when op0<op1. in either case, EF is also cleared.

---------------------------------------------------------------------------------------
III. Assembler

i. Features
Some features and quirks about the Boardinator assembler
Things it does support:
* Comments (;)
* Literals in decimal or hex (prefixed with 0x)
* Labels (for jumps)

Things it does not support (yet):
* Include directives (.include)
* Define directives
* Psuedoinstructions (call, ret)

ii. Tips
Notes about writing assembly code for the Boardinator

* Unlike in fuller-featured instruction sets, Boardinator assembly only features 1 instruction for processing literals,
the "set" instruction (which sets a given register to the literal value). Any other operation which involves a literal
must be split into 2 instructions
Ex. to do
	r0 += 10;
You'd do:
	set r1,10
	add r0,r1

* "cmp" is the only instruction which modifies the flag bits -- it must be used for conditional jumps
Ex. to do
	if(r0 > 0x35) goto label;
You'd do:
	set r1,0x35
	cmp r0,r1
	jgt label


